<?xml version="1.0" encoding="UTF-8" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="303px" preserveAspectRatio="none" style="width:1337px;height:303px;background:#FFFFFF;" version="1.1" viewBox="0 0 1337 303" width="1337px" zoomAndPan="magnify"><defs/><g><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="76" x="10" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="56" x="20" y="155.5889">加锁规则</text><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="613" x="136" y="20"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="593" x="146" y="42.9951">原则1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。</text><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,38.1484 126,38.1484 L136,38.1484 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="294" x="136" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="274" x="146" y="99.292">原则2：查找过程中访问到的对象才会加锁。</text><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="496" x="480" y="76.2969"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="476" x="490" y="99.292">注意覆盖索引的情况，如果覆盖索引可以满足加锁的条件就不会回主键加锁。</text><path d="M430,94.4453 L440,94.4453 C455,94.4453 455,94.4453 470,94.4453 L480,94.4453 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,94.4453 126,94.4453 L136,94.4453 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="538" x="136" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="518" x="146" y="155.5889">优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。</text><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="328" x="724" y="132.5938"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="308" x="734" y="155.5889">主键和唯一索引存在等值查询，可以退化为行锁。</text><path d="M674,150.7422 L684,150.7422 C699,150.7422 699,150.7422 714,150.7422 L724,150.7422 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,150.7422 126,150.7422 L136,150.7422 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="705" x="136" y="188.8906"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="685" x="146" y="211.8857">优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。</text><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="201" x="891" y="188.8906"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="181" x="901" y="211.8857">需要注意 order by 的方向。</text><path d="M841,207.0391 L851,207.0391 C866,207.0391 866,207.0391 881,207.0391 L891,207.0391 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,207.0391 126,207.0391 L136,207.0391 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="467" x="136" y="245.1875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="447" x="146" y="268.1826">一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</text><rect fill="#F1F1F1" height="36.2969" rx="12.5" ry="12.5" style="stroke:#181818;stroke-width:1.5;" width="672" x="653" y="245.1875"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="652" x="663" y="268.1826">唯一索引理论上查询到匹配的值就可以不继续向后查找，但是它并没有这么做，依然沿用了优化2的逻辑。</text><path d="M603,263.3359 L613,263.3359 C628,263.3359 628,263.3359 643,263.3359 L653,263.3359 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><path d="M86,150.7422 L96,150.7422 C111,150.7422 111,263.3359 126,263.3359 L136,263.3359 " fill="none" style="stroke:#181818;stroke-width:1.0;"/><!--MD5=[8c6c0fbc3636f72e9f3ee21ff021d3ec]
@startmindmap 加锁规则

* 加锁规则
** 原则1：加锁的基本单位是 next-key lock。希望你还记得，next-key lock 是前开后闭区间。
** 原则2：查找过程中访问到的对象才会加锁。
*** 注意覆盖索引的情况，如果覆盖索引可以满足加锁的条件就不会回主键加锁。
** 优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock 退化为行锁。
*** 主键和唯一索引存在等值查询，可以退化为行锁。
** 优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock 退化为间隙锁。
*** 需要注意 order by 的方向。
** 一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。
*** 唯一索引理论上查询到匹配的值就可以不继续向后查找，但是它并没有这么做，依然沿用了优化2的逻辑。

@endmindmap

PlantUML version 1.2022.7beta11(Unknown compile time)
(GPL source distribution)
Java Runtime: Java(TM) SE Runtime Environment
JVM: Java HotSpot(TM) 64-Bit Server VM
Default Encoding: UTF-8
Language: en
Country: US
--></g></svg>